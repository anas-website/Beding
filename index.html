<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bending Sim Mobile</title>
    <style>
        :root { 
            --primary: #0f172a; 
            --accent: #2563eb; 
            --highlight: #dc2626; 
            --bg: #f1f5f9; 
            --panel: #ffffff; 
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            background: var(--bg); 
            margin: 0; 
            padding: 10px; 
            color: #334155;
            overscroll-behavior: none; /* Prevent pull-to-refresh on mobile */
        }
        
        /* Main Layout - Responsive Grid */
        .layout {
            display: grid;
            grid-template-columns: 350px 1fr; /* Desktop: Sidebar + Canvas */
            gap: 20px;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Mobile Layout Override */
        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr; /* Stack vertically */
                display: flex;
                flex-direction: column-reverse; /* Canvas on top visually? No, Inputs usually first or Canvas first. Let's do Standard flow */
                flex-direction: column; 
            }
            .sidebar { max-height: none; overflow: visible; }
            canvas { height: 400px; } /* Smaller canvas on mobile */
        }

        /* Panels */
        .sidebar { 
            background: var(--panel); 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); 
        }
        
        .canvas-wrapper { 
            position: relative; 
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            overflow: hidden; /* Contains the canvas */
            height: 600px;
        }
        
        @media (max-width: 900px) { .canvas-wrapper { height: 50vh; min-height: 350px; } }

        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
            cursor: grab; 
            touch-action: none; /* Important for custom drag handling */
        }
        canvas:active { cursor: grabbing; }

        /* Typography & Inputs */
        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--primary); }
        h3 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; color: #64748b; margin: 20px 0 10px 0; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; }
        
        label { display: block; font-size: 0.9rem; font-weight: 600; margin-bottom: 5px; }
        input[type="number"], select { 
            width: 100%; padding: 12px; 
            border: 1px solid #cbd5e1; border-radius: 8px; 
            font-size: 1rem; box-sizing: border-box; 
            background: #fff;
            margin-bottom: 10px;
        }

        /* Slider */
        input[type="range"] { 
            width: 100%; margin: 15px 0; height: 30px; 
            cursor: pointer;
        }

        /* Floating Zoom Controls */
        .zoom-controls {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; gap: 10px;
            z-index: 10;
        }
        .zoom-btn {
            width: 45px; height: 45px;
            background: var(--primary); color: white;
            border: none; border-radius: 50%;
            font-size: 24px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            user-select: none;
        }
        .zoom-btn:active { transform: scale(0.95); background: var(--accent); }

        /* Legend */
        .legend {
            position: absolute; top: 15px; left: 15px; 
            background: rgba(255, 255, 255, 0.9); padding: 10px; 
            border-radius: 8px; font-size: 0.75rem; pointer-events: none;
            border: 1px solid #eee;
        }
        .legend-item { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
        .dot { width: 10px; height: 10px; border-radius: 3px; }

        /* Table */
        .results { background: #f8fafc; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid var(--accent); }
        table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        th { text-align: left; color: #64748b; font-size: 0.75rem; padding-bottom: 5px; }
        td { padding: 6px 0; border-bottom: 1px solid #e2e8f0; }
        .val-red { color: var(--highlight); font-weight: bold; }
    </style>
</head>
<body>

    <div class="layout">
        
        <div class="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
            
            <div class="legend">
                <div class="legend-item"><div class="dot" style="background:var(--accent)"></div> Inserted (Ext)</div>
                <div class="legend-item"><div class="dot" style="background:var(--highlight)"></div> Process (Center)</div>
                <div class="legend-item"><div class="dot" style="background:#22c55e"></div> Suction</div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" onclick="adjustZoom(0.9)">−</button>
                <button class="zoom-btn" onclick="resetView()">⟲</button>
                <button class="zoom-btn" onclick="adjustZoom(1.1)">+</button>
            </div>
        </div>

        <div class="sidebar">
            <h2>Bending Settings</h2>

            <h3>1. Material</h3>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <label>Thickness (mm) <input type="number" id="inp_T" value="2.0" step="0.1"></label>
                <label>Radius (mm) <input type="number" id="inp_R" value="2.0" step="0.1"></label>
            </div>
            <label>K-Factor <input type="number" id="inp_K" value="0.33" step="0.01"></label>

            <h3>2. Geometry</h3>
            <label>Shape Profile
                <select id="inp_Shape">
                    <option value="L">L-Shape</option>
                    <option value="C">C-Channel</option>
                    <option value="Omega">Omega (Hat)</option>
                </select>
            </label>
            <div id="dynamicInputs"></div>

            <h3>3. Simulation</h3>
            <label>Fold Progress</label>
            <input type="range" id="inp_Slider" min="0" max="100" value="0">
            <div id="step_desc" style="text-align:center; font-size:0.9rem; color:#2563eb; font-weight:bold;">Ready</div>

            <div class="results">
                <div style="font-size:0.8rem; margin-bottom:10px;">
                    <b>Total Cut Length:</b> <span id="out_Total">0.00</span> mm<br>
                    <b>Bend Allowance:</b> <span id="out_BA">0.00</span> mm
                </div>
                <table>
                    <thead><tr><th>Seg</th><th>Ext</th><th style="color:var(--highlight)">Proc</th></tr></thead>
                    <tbody id="out_Table"></tbody>
                </table>
            </div>
        </div>

    </div>

<script>
    // --- Global View State ---
    let VIEW = {
        scale: 2.0,      // Base scale
        zoom: 1.0,       // Zoom multiplier
        panX: 0,         // X Offset (panning)
        panY: 0,         // Y Offset (panning)
        isDragging: false,
        lastX: 0,
        lastY: 0
    };

    let STATE = {
        shape: 'L',
        inputs: [],
        straights: [],
        bendDirs: [],
        bendSeq: [],
        BA: 0,
        T: 2,
        R: 2
    };

    // --- Init ---
    window.onload = () => {
        buildUI();
        resizeCanvas();
        bindEvents();
        update();
        
        // Window Resize Handler
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });
    };

    function resizeCanvas() {
        const c = document.getElementById('simCanvas');
        const wrap = c.parentElement;
        // Make internal resolution match display size for crispness
        c.width = wrap.clientWidth;
        c.height = wrap.clientHeight;
        
        // Reset view center if first load
        if(VIEW.panX === 0 && VIEW.panY === 0) {
            VIEW.panX = c.width / 2;
            VIEW.panY = c.height / 2;
        }
    }

    function bindEvents() {
        document.getElementById('inp_Shape').addEventListener('change', () => { buildUI(); update(); });
        ['inp_T', 'inp_R', 'inp_K'].forEach(id => document.getElementById(id).addEventListener('input', update));
        document.getElementById('inp_Slider').addEventListener('input', draw);

        // Pan / Drag Logic
        const c = document.getElementById('simCanvas');
        
        // Mouse
        c.addEventListener('mousedown', startPan);
        window.addEventListener('mousemove', movePan); // Window to catch drag outside
        window.addEventListener('mouseup', endPan);

        // Touch
        c.addEventListener('touchstart', (e) => startPan(e.touches[0]));
        c.addEventListener('touchmove', (e) => { e.preventDefault(); movePan(e.touches[0]); }, {passive: false});
        c.addEventListener('touchend', endPan);
    }

    // --- Pan/Zoom Handlers ---
    function startPan(e) {
        VIEW.isDragging = true;
        VIEW.lastX = e.clientX;
        VIEW.lastY = e.clientY;
    }
    function movePan(e) {
        if(!VIEW.isDragging) return;
        let dx = e.clientX - VIEW.lastX;
        let dy = e.clientY - VIEW.lastY;
        VIEW.panX += dx;
        VIEW.panY += dy;
        VIEW.lastX = e.clientX;
        VIEW.lastY = e.clientY;
        draw();
    }
    function endPan() {
        VIEW.isDragging = false;
    }
    function adjustZoom(factor) {
        VIEW.zoom *= factor;
        // Clamp zoom
        if(VIEW.zoom < 0.2) VIEW.zoom = 0.2;
        if(VIEW.zoom > 5.0) VIEW.zoom = 5.0;
        draw();
    }
    function resetView() {
        const c = document.getElementById('simCanvas');
        VIEW.zoom = 1.0;
        VIEW.panX = c.width / 2;
        VIEW.panY = c.height / 2;
        draw();
    }

    // --- UI Builders ---
    function buildUI() {
        const type = document.getElementById('inp_Shape').value;
        const div = document.getElementById('dynamicInputs');
        div.innerHTML = '';
        
        let fields = [];
        if(type === 'L') {
            fields = [{l:'Leg A', v:60}, {l:'Leg B', v:60}];
        } else if(type === 'C') {
            fields = [{l:'Flange A', v:40}, {l:'Web B', v:80}, {l:'Flange C', v:40}];
        } else if(type === 'Omega') {
            fields = [
                {l:'Flange A (1)', v:30}, {l:'Web B (2)', v:50}, 
                {l:'Top C (3)', v:60}, {l:'Web D (4)', v:50}, {l:'Flange E (5)', v:30}
            ];
        }

        fields.forEach((f) => {
            div.innerHTML += `<label>${f.l} <input type="number" class="dim-field" value="${f.v}" oninput="update()"></label>`;
        });
    }

    // --- Core Calculations ---
    function update() {
        STATE.T = parseFloat(document.getElementById('inp_T').value) || 0;
        STATE.R = parseFloat(document.getElementById('inp_R').value) || 0;
        const K = parseFloat(document.getElementById('inp_K').value) || 0;
        STATE.shape = document.getElementById('inp_Shape').value;

        STATE.BA = (Math.PI / 2) * (STATE.R + (K * STATE.T));
        const corr = STATE.R + STATE.T;

        // Inputs
        let dims = [];
        document.querySelectorAll('.dim-field').forEach(el => dims.push(parseFloat(el.value)||0));
        STATE.inputs = dims;

        // Segments
        if (STATE.shape === 'L') {
            STATE.straights = [dims[0]-corr, dims[1]-corr];
            STATE.bendDirs = [-1]; 
            STATE.bendSeq = [0];
        } 
        else if (STATE.shape === 'C') {
            STATE.straights = [dims[0]-corr, dims[1]-2*corr, dims[2]-corr];
            STATE.bendDirs = [-1, -1]; 
            STATE.bendSeq = [0, 1];
        } 
        else if (STATE.shape === 'Omega') {
            // A, B, C, D, E
            STATE.straights = [
                dims[0]-corr, dims[1]-2*corr, dims[2]-2*corr, dims[3]-2*corr, dims[4]-corr
            ];
            STATE.bendDirs = [-1, 1, 1, -1]; // Directions
            STATE.bendSeq = [0, 3, 1, 2]; // Sequence: A, E, B, D
        }

        updateTable(dims, corr, STATE.BA);
        draw();
    }

    function updateTable(ext, corr, BA) {
        const tb = document.getElementById('out_Table');
        tb.innerHTML = '';
        let total = 0;

        STATE.straights.forEach((s, i) => {
            let proc = 0;
            let isEnd = (i===0 || i===STATE.straights.length-1);

            // Special Omega Logic for Web B (idx 1) and Web D (idx 3)
            if (STATE.shape === 'Omega' && (i === 1 || i === 3)) {
                proc = ext[i] - corr + (BA/2);
            } else if(isEnd) {
                proc = ext[i] - corr + (BA/2);
            } else {
                proc = ext[i] - 2*corr + BA;
            }
            total += proc;

            tb.innerHTML += `<tr>
                <td>${i+1}</td>
                <td style="color:var(--accent)">${ext[i].toFixed(1)}</td>
                <td class="val-red">${proc.toFixed(2)}</td>
            </tr>`;
        });
        document.getElementById('out_Total').innerText = total.toFixed(2);
        document.getElementById('out_BA').innerText = BA.toFixed(2);
    }

    // --- Drawing ---
    function draw() {
        const c = document.getElementById('simCanvas');
        const ctx = c.getContext('2d');
        const W = c.width; const H = c.height;

        ctx.clearRect(0,0,W,H);

        // Simulation Step
        const slider = parseFloat(document.getElementById('inp_Slider').value);
        const progress = slider / 100;
        
        let angles = new Array(STATE.bendDirs.length).fill(0);
        let steps = STATE.bendSeq.length;
        let stepIdx = Math.floor(progress * steps);
        if(stepIdx >= steps) stepIdx = steps-1;
        let localP = (progress * steps) - stepIdx;
        
        // Set Completed
        for(let i=0; i<stepIdx; i++) {
            let b = STATE.bendSeq[i];
            angles[b] = (Math.PI/2) * STATE.bendDirs[b];
        }
        // Set Active
        if(progress > 0) {
            let b = STATE.bendSeq[stepIdx];
            angles[b] = ((Math.PI/2) * STATE.bendDirs[b]) * localP;
        }

        // Labels
        const lbls = STATE.shape === 'Omega' 
            ? ['1. Flange A', '2. Flange E', '3. Web B', '4. Web D'] 
            : [`Bend ${stepIdx+1}`, `Bend ${stepIdx+2}`];
        document.getElementById('step_desc').innerText = (progress==0) ? "Flat Pattern" : (lbls[stepIdx] || "Finished");

        // Build Geometry
        let nodes = [{x:0, y:0}];
        let ca = 0;
        for(let i=0; i<STATE.straights.length; i++){
            let len = STATE.straights[i];
            nodes.push({
                x: nodes[i].x + len * Math.cos(ca),
                y: nodes[i].y + len * Math.sin(ca)
            });
            if(i < angles.length) ca += angles[i];
        }

        // Camera Transforms
        ctx.save();
        ctx.translate(VIEW.panX, VIEW.panY);
        const S = VIEW.scale * VIEW.zoom; // Final Scale

        // Anchor Logic (Hold Specific Segment Flat)
        let anchor = 0;
        if(STATE.shape === 'C') anchor = (stepIdx>=1) ? 1 : 0;
        if(STATE.shape === 'Omega') {
             // 0(A) holds 1(B), 1(E) holds 3(D), 2(B) holds 2(C), 3(D) holds 2(C)
             const anchors = [1, 3, 2, 2];
             anchor = anchors[stepIdx] || 0;
             if(progress===0) anchor = 2; // Flat starts centered on top
        }

        let p1 = nodes[anchor];
        let p2 = nodes[anchor+1];
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        let mx = (p1.x+p2.x)/2; 
        let my = (p1.y+p2.y)/2;

        ctx.rotate(-ang); // Flatten Anchor
        ctx.translate(-mx*S, -my*S); // Center Anchor at Pan Origin

        // Draw Machine Bed
        let yLvl = p1.y*S + (STATE.T*S/2);
        ctx.fillStyle = "#e2e8f0";
        ctx.fillRect(mx*S - 300, yLvl + 2, 600, 20); // Bed
        ctx.fillStyle = "#94a3b8";
        ctx.beginPath();
        ctx.moveTo(mx*S - 20, yLvl + 25); ctx.lineTo(mx*S, yLvl + 2); ctx.lineTo(mx*S + 20, yLvl + 25);
        ctx.fill();

        // Draw Part
        ctx.lineJoin = "round"; ctx.lineCap = "round";
        ctx.lineWidth = STATE.T * S;
        ctx.strokeStyle = "#334155";
        ctx.beginPath();
        nodes.forEach((n,i)=>{
            i==0 ? ctx.moveTo(n.x*S, n.y*S) : ctx.lineTo(n.x*S, n.y*S);
        });
        ctx.stroke();

        // Draw Dimensions
        STATE.straights.forEach((st, i)=>{
            let n1 = nodes[i], n2 = nodes[i+1];
            // Calc Val
            let val = 0; 
            let corr = STATE.R+STATE.T;
            let isEnd = (i==0 || i==STATE.straights.length-1);
            if(STATE.shape=='Omega' && (i==1 || i==3)) val = STATE.inputs[i] - corr + (STATE.BA/2);
            else if(isEnd) val = STATE.inputs[i] - corr + (STATE.BA/2);
            else val = STATE.inputs[i] - 2*corr + STATE.BA;

            // Offsets
            let oR = (STATE.T*S) + (30 * VIEW.zoom); // Process
            let oB = (STATE.T*S) + (60 * VIEW.zoom); // Ext

            drawDim(ctx, n1, n2, oR, val.toFixed(2), '#dc2626', S);
            drawDim(ctx, n1, n2, oB, STATE.inputs[i].toFixed(1), '#2563eb', S, true);
        });

        // Suction
        drawSuction(ctx, nodes[anchor], nodes[anchor+1], S);

        ctx.restore();
    }

    function drawDim(ctx, p1, p2, off, txt, col, S, ext=false) {
        let ux = (p2.x-p1.x), uy = (p2.y-p1.y);
        let len = Math.sqrt(ux*ux + uy*uy);
        ux/=len; uy/=len;
        let nx = -uy, ny = ux;

        let eLen = ext ? (STATE.T*S + STATE.R*S) : 0;
        
        let s1x = p1.x*S, s1y = p1.y*S;
        let s2x = p2.x*S, s2y = p2.y*S;

        let d1x = s1x + nx*off - ux*eLen;
        let d1y = s1y + ny*off - uy*eLen;
        let d2x = s2x + nx*off + ux*eLen;
        let d2y = s2y + ny*off + uy*eLen;

        ctx.save();
        ctx.strokeStyle = col; ctx.fillStyle = col;
        ctx.lineWidth = 1; ctx.font = `bold ${12 * VIEW.zoom}px sans-serif`;

        // Lines
        ctx.beginPath();
        ctx.moveTo(s1x,s1y); ctx.lineTo(d1x,d1y);
        ctx.moveTo(s2x,s2y); ctx.lineTo(d2x,d2y);
        ctx.stroke();
        ctx.beginPath(); ctx.moveTo(d1x,d1y); ctx.lineTo(d2x,d2y); ctx.stroke();

        // Text
        let mx = (d1x+d2x)/2, my = (d1y+d2y)/2;
        let ang = Math.atan2(ny, nx) - (Math.PI/2); // Perpendicular to normal is parallel
        // Actually simpler: atan2 of segment
        ang = Math.atan2(uy, ux);
        if(ang > Math.PI/2 || ang < -Math.PI/2) ang += Math.PI;

        ctx.translate(mx,my); ctx.rotate(ang);
        let tw = ctx.measureText(txt).width + 6;
        ctx.clearRect(-tw/2, -10*VIEW.zoom, tw, 20*VIEW.zoom);
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(txt, 0, 0);

        ctx.restore();
    }

    function drawSuction(ctx, p1, p2, S) {
        let cx = (p1.x+p2.x)/2 * S;
        let cy = (p1.y+p2.y)/2 * S;
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);

        ctx.save();
        ctx.translate(cx,cy); ctx.rotate(ang);
        ctx.strokeStyle = "#16a34a"; ctx.fillStyle = "rgba(34,197,94,0.3)";
        ctx.lineWidth = 2;

        let sz = 8 * VIEW.zoom;
        let off = 20 * VIEW.zoom;

        [-off, off].forEach(x => {
            ctx.beginPath();
            ctx.arc(x, -STATE.T*S - sz, sz, 0, Math.PI*2);
            ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x, -STATE.T*S - sz*2); ctx.lineTo(x, -STATE.T*S - sz*4); ctx.stroke();
        });
        ctx.beginPath(); ctx.moveTo(-off, -STATE.T*S - sz*4); ctx.lineTo(off, -STATE.T*S - sz*4); ctx.stroke();
        ctx.restore();
    }

</script>
</body>
</html>
