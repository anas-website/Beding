<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Bending Sim</title>
    <style>
        :root { 
            --primary: #333; /* Darker, more CAD-like */
            --accent: #2962ff; 
            --dim-red: #d50000;
            --dim-blue: #0044ff;
            --bg: #f0f2f5; 
            --panel: #ffffff; 
        }

        body { 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            background: var(--bg); 
            margin: 0; 
            padding: 10px; 
            color: #333;
            overscroll-behavior: none;
        }
        
        .layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 15px;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
        }

        @media (max-width: 900px) {
            .layout { grid-template-columns: 1fr; }
            .canvas-wrapper { height: 50vh; min-height: 400px; }
        }

        .sidebar { 
            background: var(--panel); 
            padding: 20px; 
            border-radius: 8px; 
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
        }
        
        .canvas-wrapper { 
            position: relative; 
            background: #fff;
            border-radius: 8px;
            border: 1px solid #ccc;
            overflow: hidden;
            height: 700px;
            /* Grid background for CAD feel */
            background-image: linear-gradient(#f0f0f0 1px, transparent 1px), linear-gradient(90deg, #f0f0f0 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas { width: 100%; height: 100%; cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }

        h2 { margin: 0 0 15px 0; font-size: 1.1rem; color: var(--primary); text-transform: uppercase; border-bottom: 2px solid #333; padding-bottom: 5px; }
        h3 { font-size: 0.8rem; font-weight: 700; color: #666; margin: 15px 0 8px 0; }
        
        label { display: block; font-size: 0.85rem; font-weight: 600; margin-bottom: 4px; color: #444; }
        input[type="number"], select { 
            width: 100%; padding: 8px; 
            border: 1px solid #bbb; border-radius: 4px; 
            font-size: 0.9rem; box-sizing: border-box; 
            background: #fafafa; margin-bottom: 8px;
        }
        input:focus { border-color: var(--accent); outline: none; background: #fff; }

        input[type="range"] { width: 100%; margin: 15px 0; cursor: pointer; }

        .zoom-controls {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; gap: 8px; z-index: 10;
        }
        .zoom-btn {
            width: 40px; height: 40px;
            background: #fff; color: #333;
            border: 1px solid #999; border-radius: 4px;
            font-size: 20px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .zoom-btn:active { background: #eee; }

        .results { 
            background: #fff; border: 1px solid #ccc; 
            padding: 10px; border-radius: 4px; margin-top: 15px; 
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        th { text-align: left; background: #eee; padding: 5px; border-bottom: 1px solid #ccc; }
        td { padding: 5px; border-bottom: 1px solid #eee; }
        .val-red { color: var(--dim-red); font-weight: bold; }
        .val-blue { color: var(--dim-blue); font-weight: bold; }
    </style>
</head>
<body>

    <div class="layout">
        <div class="canvas-wrapper">
            <canvas id="simCanvas"></canvas>
            
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="resetView()">fit</button>
                <button class="zoom-btn" onclick="adjustZoom(0.9)">−</button>
                <button class="zoom-btn" onclick="adjustZoom(1.1)">+</button>
            </div>
            
            <div style="position:absolute; top:10px; left:10px; background:rgba(255,255,255,0.9); border:1px solid #999; padding:5px 10px; font-size:11px; font-family:monospace;">
                <span style="color:var(--dim-blue); font-weight:bold;">───</span> External Dim<br>
                <span style="color:var(--dim-red); font-weight:bold;">───</span> Process Dim<br>
                <span style="color:#000; font-weight:bold;">═══</span> Suction
            </div>
        </div>

        <div class="sidebar">
            <h2>Configuration</h2>

            <h3>MATERIAL</h3>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                <label>Thickness (T)<input type="number" id="inp_T" value="2.0" step="0.1"></label>
                <label>Radius (R)<input type="number" id="inp_R" value="2.0" step="0.1"></label>
            </div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                <label>K-Factor<input type="number" id="inp_K" value="0.33" step="0.01"></label>
                <label>Angle (°)<input type="number" id="inp_A" value="90" min="70" max="180" onchange="validateAngle()"></label>
            </div>

            <h3>PROFILE</h3>
            <label>Shape
                <select id="inp_Shape">
                    <option value="L">L-Shape</option>
                    <option value="C">C-Channel</option>
                    <option value="Omega">Omega (Hat)</option>
                </select>
            </label>
            <div id="dynamicInputs"></div>

            <h3>SIMULATION</h3>
            <input type="range" id="inp_Slider" min="0" max="100" value="0">
            <div id="step_desc" style="text-align:center; font-size:0.85rem; font-weight:bold; color:#555;">FLAT PATTERN</div>

            <div class="results">
                <div style="font-size:0.8rem; margin-bottom:5px;">
                    Total Length: <b id="out_Total">0.00</b> mm<br>
                    Bend Allowance: <b id="out_BA">0.00</b> mm<br>
                    Outside Setback: <b id="out_OSSB">0.00</b> mm
                </div>
                <table>
                    <thead><tr><th>#</th><th>External</th><th>Process</th></tr></thead>
                    <tbody id="out_Table"></tbody>
                </table>
            </div>
        </div>
    </div>

<script>
    // --- State & View ---
    let VIEW = { scale: 2.5, zoom: 1.0, panX: 0, panY: 0, isDragging: false, lastX: 0, lastY: 0 };
    let STATE = { shape: 'L', inputs: [], straights: [], bendDirs: [], bendSeq: [], BA: 0, T: 2, R: 2, Angle: 90, OSSB: 0 };

    window.onload = () => {
        buildUI(); resizeCanvas(); bindEvents(); update();
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });
    };

    function validateAngle() {
        let el = document.getElementById('inp_A');
        let val = parseFloat(el.value);
        if(val < 70) el.value = 70; if(val > 180) el.value = 180;
        update();
    }

    function resizeCanvas() {
        const c = document.getElementById('simCanvas');
        const wrap = c.parentElement;
        c.width = wrap.clientWidth; c.height = wrap.clientHeight;
        if(VIEW.panX === 0) { VIEW.panX = c.width/2; VIEW.panY = c.height/2; }
    }

    function bindEvents() {
        document.getElementById('inp_Shape').addEventListener('change', () => { buildUI(); update(); });
        ['inp_T', 'inp_R', 'inp_K', 'inp_A'].forEach(id => document.getElementById(id).addEventListener('input', update));
        document.getElementById('inp_Slider').addEventListener('input', draw);
        
        const c = document.getElementById('simCanvas');
        c.addEventListener('mousedown', startPan);
        window.addEventListener('mousemove', movePan);
        window.addEventListener('mouseup', endPan);
        c.addEventListener('touchstart', (e) => startPan(e.touches[0]));
        c.addEventListener('touchmove', (e) => { e.preventDefault(); movePan(e.touches[0]); }, {passive: false});
        c.addEventListener('touchend', endPan);
    }

    function startPan(e) { VIEW.isDragging = true; VIEW.lastX = e.clientX; VIEW.lastY = e.clientY; }
    function movePan(e) {
        if(!VIEW.isDragging) return;
        VIEW.panX += e.clientX - VIEW.lastX; VIEW.panY += e.clientY - VIEW.lastY;
        VIEW.lastX = e.clientX; VIEW.lastY = e.clientY; draw();
    }
    function endPan() { VIEW.isDragging = false; }
    function adjustZoom(f) { VIEW.zoom = Math.max(0.2, Math.min(5.0, VIEW.zoom * f)); draw(); }
    function resetView() { const c = document.getElementById('simCanvas'); VIEW.zoom = 1.0; VIEW.panX = c.width/2; VIEW.panY = c.height/2; draw(); }

    function buildUI() {
        const type = document.getElementById('inp_Shape').value;
        const div = document.getElementById('dynamicInputs');
        div.innerHTML = '';
        let fields = [];
        if(type === 'L') fields = [{l:'Leg A', v:60}, {l:'Leg B', v:60}];
        else if(type === 'C') fields = [{l:'Flange A', v:40}, {l:'Web B', v:80}, {l:'Flange C', v:40}];
        else if(type === 'Omega') fields = [{l:'Flange A', v:30}, {l:'Web B', v:50}, {l:'Top C', v:60}, {l:'Web D', v:50}, {l:'Flange E', v:30}];
        fields.forEach(f => div.innerHTML += `<label>${f.l} <input type="number" class="dim-field" value="${f.v}" oninput="update()"></label>`);
    }

    function update() {
        STATE.T = parseFloat(document.getElementById('inp_T').value) || 0;
        STATE.R = parseFloat(document.getElementById('inp_R').value) || 0;
        const K = parseFloat(document.getElementById('inp_K').value) || 0;
        STATE.Angle = parseFloat(document.getElementById('inp_A').value);
        if(STATE.Angle < 70) STATE.Angle = 70; if(STATE.Angle > 180) STATE.Angle = 180;
        STATE.shape = document.getElementById('inp_Shape').value;

        // Calc Geometry
        const bendRad = (180 - STATE.Angle) * (Math.PI / 180);
        STATE.BA = bendRad * (STATE.R + (K * STATE.T));
        STATE.OSSB = (STATE.R + STATE.T) * Math.tan(bendRad / 2);

        let dims = [];
        document.querySelectorAll('.dim-field').forEach(el => dims.push(parseFloat(el.value)||0));
        STATE.inputs = dims;

        if (STATE.shape === 'L') {
            STATE.straights = [dims[0]-STATE.OSSB, dims[1]-STATE.OSSB];
            STATE.bendDirs = [-1]; STATE.bendSeq = [0];
        } 
        else if (STATE.shape === 'C') {
            STATE.straights = [dims[0]-STATE.OSSB, dims[1]-(2*STATE.OSSB), dims[2]-STATE.OSSB];
            STATE.bendDirs = [-1, -1]; STATE.bendSeq = [0, 1];
        } 
        else if (STATE.shape === 'Omega') {
            STATE.straights = [
                dims[0]-STATE.OSSB, dims[1]-(2*STATE.OSSB), dims[2]-(2*STATE.OSSB), 
                dims[3]-(2*STATE.OSSB), dims[4]-STATE.OSSB
            ];
            STATE.bendDirs = [-1, 1, 1, -1]; STATE.bendSeq = [0, 3, 1, 2];
        }

        updateTable(dims);
        draw();
    }

    function updateTable(ext) {
        const tb = document.getElementById('out_Table');
        tb.innerHTML = '';
        let total = 0;
        STATE.straights.forEach((s, i) => {
            let proc = 0;
            let isEnd = (i===0 || i===STATE.straights.length-1);
            let isOmegaWeb = (STATE.shape === 'Omega' && (i === 1 || i === 3));
            
            if (isOmegaWeb || isEnd) proc = ext[i] - STATE.OSSB + (STATE.BA/2);
            else proc = ext[i] - (2*STATE.OSSB) + STATE.BA;
            
            total += proc;
            tb.innerHTML += `<tr><td>${i+1}</td><td class="val-blue">${ext[i].toFixed(1)}</td><td class="val-red">${proc.toFixed(2)}</td></tr>`;
        });
        document.getElementById('out_Total').innerText = total.toFixed(2);
        document.getElementById('out_BA').innerText = STATE.BA.toFixed(2);
        document.getElementById('out_OSSB').innerText = STATE.OSSB.toFixed(2);
    }

    function draw() {
        const c = document.getElementById('simCanvas');
        const ctx = c.getContext('2d');
        const W = c.width; const H = c.height;
        ctx.clearRect(0,0,W,H);

        const slider = parseFloat(document.getElementById('inp_Slider').value);
        const progress = slider / 100;
        
        // --- Calculate Angles ---
        let angles = new Array(STATE.bendDirs.length).fill(0);
        let steps = STATE.bendSeq.length;
        let stepIdx = Math.floor(progress * steps);
        if(stepIdx >= steps) stepIdx = steps-1;
        let localP = (progress * steps) - stepIdx;
        const targetBendRad = (180 - STATE.Angle) * (Math.PI/180);

        for(let i=0; i<stepIdx; i++) {
            let b = STATE.bendSeq[i];
            angles[b] = targetBendRad * STATE.bendDirs[b];
        }
        if(progress > 0) {
            let b = STATE.bendSeq[stepIdx];
            angles[b] = (targetBendRad * STATE.bendDirs[b]) * localP;
        }

        const lbls = STATE.shape === 'Omega' ? ['A (Flange)', 'E (Flange)', 'B (Web)', 'D (Web)'] : [`Bend ${stepIdx+1}`, `Bend ${stepIdx+2}`];
        document.getElementById('step_desc').innerText = (progress==0) ? "FLAT PATTERN" : (lbls[stepIdx] || "FINISHED");

        // --- Build Path (Nodes at Neutral Axis) ---
        let nodes = [{x:0, y:0}];
        let ca = 0;
        for(let i=0; i<STATE.straights.length; i++){
            let len = STATE.straights[i];
            nodes.push({ x: nodes[i].x + len * Math.cos(ca), y: nodes[i].y + len * Math.sin(ca) });
            if(i < angles.length) ca += angles[i];
        }

        // --- Camera Transform ---
        ctx.save();
        ctx.translate(VIEW.panX, VIEW.panY);
        const S = VIEW.scale * VIEW.zoom;

        // Anchor Logic
        let anchor = 0;
        if(STATE.shape === 'C') anchor = (stepIdx>=1) ? 1 : 0;
        if(STATE.shape === 'Omega') {
             const anchors = [1, 3, 2, 2];
             anchor = anchors[stepIdx] || 0;
             if(progress===0) anchor = 2;
        }
        let p1 = nodes[anchor]; let p2 = nodes[anchor+1];
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        let mx = (p1.x+p2.x)/2; let my = (p1.y+p2.y)/2;

        ctx.rotate(-ang); ctx.translate(-mx*S, -my*S);

        // --- Draw Bed ---
        let yLvl = p1.y*S + (STATE.T*S/2); // Bottom surface of anchored part
        ctx.fillStyle = "#e0e0e0"; ctx.fillRect(mx*S - 350, yLvl + 2, 700, 20); // Bed plate
        ctx.strokeStyle = "#999"; ctx.strokeRect(mx*S - 350, yLvl + 2, 700, 20);
        
        // V-Die
        ctx.fillStyle = "#bbb"; 
        ctx.beginPath(); ctx.moveTo(mx*S - 25, yLvl + 30); ctx.lineTo(mx*S, yLvl + 2); ctx.lineTo(mx*S + 25, yLvl + 30); ctx.fill(); ctx.stroke();

        // --- Draw Part ---
        ctx.lineJoin = "round"; ctx.lineCap = "round";
        ctx.lineWidth = STATE.T * S; ctx.strokeStyle = "#444";
        ctx.beginPath(); nodes.forEach((n,i)=>{ i==0 ? ctx.moveTo(n.x*S, n.y*S) : ctx.lineTo(n.x*S, n.y*S); }); ctx.stroke();
        
        // Draw thin centerline
        ctx.lineWidth = 1; ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.stroke();

        // --- Draw Dimensions ---
        STATE.straights.forEach((st, i)=>{
            let n1 = nodes[i], n2 = nodes[i+1];
            
            // Process Value
            let val = 0; 
            let isEnd = (i==0 || i==STATE.straights.length-1);
            let isOmegaWeb = (STATE.shape === 'Omega' && (i === 1 || i === 3));
            if(isOmegaWeb || isEnd) val = STATE.inputs[i] - STATE.OSSB + (STATE.BA/2);
            else val = STATE.inputs[i] - 2*STATE.OSSB + STATE.BA;

            // Offsets
            let oR = (STATE.T*S) + (25 * VIEW.zoom); // Process (Red) - Closer
            let oB = (STATE.T*S) + (55 * VIEW.zoom); // External (Blue) - Further

            drawDim(ctx, n1, n2, oR, val.toFixed(2), '#d50000', S, false);
            drawDim(ctx, n1, n2, oB, STATE.inputs[i].toFixed(1), '#0044ff', S, true);
        });

        // --- Draw Suction (Tech Style) ---
        drawSuction(ctx, nodes[anchor], nodes[anchor+1], S);
        ctx.restore();
    }

    function drawDim(ctx, p1, p2, off, txt, col, S, ext=false) {
        let ux = (p2.x-p1.x), uy = (p2.y-p1.y);
        let len = Math.sqrt(ux*ux + uy*uy);
        ux/=len; uy/=len;
        let nx = -uy, ny = ux;

        // Start points at Neutral Axis
        let s1x = p1.x*S, s1y = p1.y*S; 
        let s2x = p2.x*S, s2y = p2.y*S;

        // Shift Start points to OUTER Surface
        // Vector normal to surface is N. Surface is at N * (T/2).
        let halfT = (STATE.T*S)/2;
        let surf1x = s1x + nx*halfT; let surf1y = s1y + ny*halfT;
        let surf2x = s2x + nx*halfT; let surf2y = s2y + ny*halfT;

        // Extension for Corner (Virtual Sharp)
        // If External Dim, extend witness line origin outwards along U by OSSB
        let eLen = ext ? (STATE.OSSB * S) : 0; 
        
        let w1x = surf1x - ux*eLen; let w1y = surf1y - uy*eLen; // Extend backwards for start
        let w2x = surf2x + ux*eLen; let w2y = surf2y + uy*eLen; // Extend forwards for end

        // Witness Line End Points (at Dimension line height)
        // off is distance from Neutral Axis. 
        // We need distance from Surface = off - halfT. 
        // Actually, let's just use N*off from Neutral Axis for consistency of height
        let d1x = s1x + nx*off - ux*eLen; let d1y = s1y + ny*off - uy*eLen;
        let d2x = s2x + nx*off + ux*eLen; let d2y = s2y + ny*off + uy*eLen;

        ctx.save();
        ctx.strokeStyle = col; ctx.fillStyle = col;
        ctx.lineWidth = 1; ctx.font = `bold ${11 * VIEW.zoom}px monospace`;

        // Draw Witness Lines (From Surface to Dim Line)
        // Small gap from surface
        let gap = 3 * VIEW.zoom;
        ctx.beginPath();
        ctx.moveTo(w1x + nx*gap, w1y + ny*gap); ctx.lineTo(d1x, d1y);
        ctx.moveTo(w2x + nx*gap, w2y + ny*gap); ctx.lineTo(d2x, d2y);
        ctx.stroke();

        // Draw Dim Line
        ctx.beginPath(); ctx.moveTo(d1x, d1y); ctx.lineTo(d2x, d2y); ctx.stroke();

        // Arrows (Technical)
        drawArrow(ctx, {x:d1x, y:d1y}, {x:d2x, y:d2y}, VIEW.zoom);
        drawArrow(ctx, {x:d2x, y:d2y}, {x:d1x, y:d1y}, VIEW.zoom);

        // Text
        let mx = (d1x+d2x)/2, my = (d1y+d2y)/2;
        let ang = Math.atan2(uy, ux);
        if(ang > Math.PI/2 || ang < -Math.PI/2) ang += Math.PI;

        ctx.translate(mx,my); ctx.rotate(ang);
        let tw = ctx.measureText(txt).width + 6;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(-tw/2, -6*VIEW.zoom, tw, 12*VIEW.zoom);
        ctx.fillStyle = col;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(txt, 0, 0);
        ctx.restore();
    }

    function drawArrow(ctx, p1, p2, z) {
        let size = 6 * z;
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p1.x + size * Math.cos(ang + Math.PI/6), p1.y + size * Math.sin(ang + Math.PI/6));
        ctx.lineTo(p1.x + size * Math.cos(ang - Math.PI/6), p1.y + size * Math.sin(ang - Math.PI/6));
        ctx.closePath();
        ctx.fill();
    }

    function drawSuction(ctx, p1, p2, S) {
        // Technical Drawing Style: Two flat pads (lines)
        let cx = (p1.x+p2.x)/2 * S; let cy = (p1.y+p2.y)/2 * S;
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);

        ctx.save();
        ctx.translate(cx,cy); ctx.rotate(ang);
        
        ctx.strokeStyle = "#222"; 
        ctx.fillStyle = "rgba(50,50,50,0.1)";
        ctx.lineWidth = 2;

        let padW = 12 * VIEW.zoom; // Width of pad
        let padH = 4 * VIEW.zoom;  // Height of pad
        let offX = 25 * VIEW.zoom; // Distance from center
        let distFromSurf = (STATE.T*S)/2; 

        // Draw Left Pad
        ctx.beginPath();
        ctx.rect(-offX - padW/2, -distFromSurf - padH, padW, padH);
        ctx.fill(); ctx.stroke();

        // Draw Right Pad
        ctx.beginPath();
        ctx.rect(offX - padW/2, -distFromSurf - padH, padW, padH);
        ctx.fill(); ctx.stroke();

        // Draw Connecting structure (Simplified gripper body)
        ctx.beginPath();
        // Lines going up from pads
        ctx.moveTo(-offX, -distFromSurf - padH); ctx.lineTo(-offX, -distFromSurf - padH - 15*VIEW.zoom);
        ctx.moveTo(offX, -distFromSurf - padH); ctx.lineTo(offX, -distFromSurf - padH - 15*VIEW.zoom);
        // Crossbar
        ctx.moveTo(-offX, -distFromSurf - padH - 15*VIEW.zoom); ctx.lineTo(offX, -distFromSurf - padH - 15*VIEW.zoom);
        // Vertical Stem
        ctx.moveTo(0, -distFromSurf - padH - 15*VIEW.zoom); ctx.lineTo(0, -distFromSurf - padH - 35*VIEW.zoom);
        ctx.stroke();

        ctx.restore();
    }
</script>
</body>
</html>
