<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Frednzon CAD Sim - Radii</title>
    <style>
        :root {
            --ui-bg: #f5f6f7;
            --panel-bg: #ffffff;
            --dim-blue: #0055ff;
            --dim-red: #d50000;
            --metal-fill: #e0f2f1; /* Light Teal/Greenish like CAD highlights */
            --metal-stroke: #263238;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--ui-bg);
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* Responsive Layout */
        .app-container { display: flex; flex-direction: column; height: 100%; }
        @media (min-width: 900px) {
            .app-container { flex-direction: row-reverse; }
            .canvas-area { flex: 2; height: 100% !important; border-left: 1px solid #ccc; }
            .controls-area { flex: 1; max-width: 400px; }
        }

        /* Canvas */
        .canvas-area {
            position: relative;
            height: 50vh;
            background: #ffffff;
            /* Engineering Grid */
            background-image: linear-gradient(#eee 1px, transparent 1px), linear-gradient(90deg, #eee 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            touch-action: none;
            border-bottom: 1px solid #ccc;
        }
        canvas { display: block; width: 100%; height: 100%; }

        .overlay-tools {
            position: absolute; bottom: 10px; right: 10px;
            display: flex; gap: 8px;
        }
        .tool-btn {
            width: 40px; height: 40px;
            background: #fff; border: 1px solid #ccc; border-radius: 8px;
            font-size: 18px; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); cursor: pointer;
        }

        /* Controls */
        .controls-area {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: var(--ui-bg);
        }

        .panel {
            background: var(--panel-bg); border-radius: 6px;
            padding: 12px; margin-bottom: 10px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        h2 { margin: 0 0 10px 0; font-size: 13px; color: #444; border-bottom: 2px solid #263238; display: inline-block; text-transform: uppercase; }
        
        .row { display: flex; gap: 10px; margin-bottom: 8px; }
        .col { flex: 1; }
        label { display: block; font-size: 11px; font-weight: 700; color: #546e7a; margin-bottom: 3px; }
        input[type="number"], select {
            width: 100%; padding: 8px; border: 1px solid #cfd8dc;
            border-radius: 4px; font-size: 14px; background: #fafafa;
        }
        input:focus { border-color: #2196f3; outline: none; background: #fff; }

        /* Results */
        table { width: 100%; border-collapse: collapse; font-size: 11px; }
        th { text-align: left; background: #eceff1; padding: 6px; color: #455a64; }
        td { padding: 6px; border-bottom: 1px solid #eee; }
        .val-ext { color: var(--dim-blue); font-weight: 700; }
        .val-proc { color: var(--dim-red); font-weight: 700; }

        .legend {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.9); padding: 5px 8px;
            border: 1px solid #ccc; font-family: monospace; font-size: 10px;
            pointer-events: none;
        }

    </style>
</head>
<body>

<div class="app-container">
    <div class="canvas-area">
        <canvas id="simCanvas"></canvas>
        
        <div class="legend">
            <span style="color:var(--dim-blue)">━━━</span> External (On Line)<br>
            <span style="color:var(--dim-red)">━━━</span> Process (Center)<br>
            <span style="color:#000">═══</span> Suction
        </div>

        <div class="overlay-tools">
            <div class="tool-btn" onclick="resetView()">⟲</div>
            <div class="tool-btn" onclick="adjustZoom(0.9)">−</div>
            <div class="tool-btn" onclick="adjustZoom(1.1)">+</div>
        </div>
    </div>

    <div class="controls-area">
        <div class="panel">
            <h2>Geometry</h2>
            <div class="row">
                <div class="col"><label>Thickness (mm)</label><input type="number" id="inp_T" value="2.0" step="0.1"></div>
                <div class="col"><label>Inner Radius</label><input type="number" id="inp_R" value="3.0" step="0.1"></div>
            </div>
            <div class="row">
                <div class="col"><label>Angle (°)</label><input type="number" id="inp_A" value="90" min="70" max="180"></div>
                <div class="col"><label>K-Factor</label><input type="number" id="inp_K" value="0.33" step="0.01"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Profile</h2>
            <select id="inp_Shape" style="margin-bottom:10px;">
                <option value="L">L-Shape</option>
                <option value="C">C-Channel</option>
                <option value="Omega">Omega (Hat)</option>
            </select>
            <div id="dynamicInputs"></div>
        </div>

        <div class="panel">
            <div style="display:flex; justify-content:space-between; font-size:11px; margin-bottom:5px;">
                <span>Length: <b id="out_Total">0.00</b></span>
                <span>BA: <b id="out_BA">0.00</b></span>
            </div>
            <input type="range" id="inp_Slider" min="0" max="100" value="0" style="width:100%;">
            <div style="text-align:center; font-size:10px; font-weight:bold; color:#666; margin-top:5px;" id="step_desc">FLAT PATTERN</div>
        </div>

        <div class="panel" style="padding:0;">
            <table id="out_Table">
                <thead><tr><th>SEG</th><th>EXTERNAL</th><th>PROCESS</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        <div style="height:40px;"></div>
    </div>
</div>

<script>
    // --- State ---
    let VIEW = { scale: 2.0, zoom: 1.0, panX: 0, panY: 0, dragging: false, lx: 0, ly: 0 };
    let STATE = { shape: 'L', inputs: [], straights: [], bendDirs: [], bendSeq: [], BA: 0, OSSB: 0, T: 2, R: 3, Angle: 90 };

    // --- Init ---
    window.onload = () => {
        buildUI(); resizeCanvas(); bindEvents(); update();
        document.getElementById('simCanvas').addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    };

    window.addEventListener('resize', () => { resizeCanvas(); draw(); });

    function resizeCanvas() {
        const c = document.getElementById('simCanvas');
        c.width = c.clientWidth; c.height = c.clientHeight;
        if(VIEW.panX===0) { VIEW.panX = c.width/2; VIEW.panY = c.height/2; }
    }

    function bindEvents() {
        document.getElementById('inp_Shape').addEventListener('change', () => { buildUI(); update(); });
        ['inp_T', 'inp_R', 'inp_K', 'inp_A'].forEach(id => document.getElementById(id).addEventListener('input', update));
        document.getElementById('inp_Slider').addEventListener('input', draw);
        
        const c = document.getElementById('simCanvas');
        const start = (x,y) => { VIEW.dragging=true; VIEW.lx=x; VIEW.ly=y; };
        const move = (x,y) => { if(!VIEW.dragging)return; VIEW.panX+=x-VIEW.lx; VIEW.panY+=y-VIEW.ly; VIEW.lx=x; VIEW.ly=y; draw(); };
        const end = () => { VIEW.dragging=false; };

        c.addEventListener('mousedown', e=>start(e.clientX,e.clientY));
        window.addEventListener('mousemove', e=>move(e.clientX,e.clientY));
        window.addEventListener('mouseup', end);
        c.addEventListener('touchstart', e=>start(e.touches[0].clientX,e.touches[0].clientY));
        c.addEventListener('touchmove', e=>move(e.touches[0].clientX,e.touches[0].clientY));
        c.addEventListener('touchend', end);
    }

    function adjustZoom(f) { VIEW.zoom = Math.max(0.2, Math.min(8.0, VIEW.zoom*f)); draw(); }
    function resetView() { const c = document.getElementById('simCanvas'); VIEW.zoom=1.0; VIEW.panX=c.width/2; VIEW.panY=c.height/2; draw(); }

    // --- Logic ---
    function buildUI() {
        const type = document.getElementById('inp_Shape').value;
        const div = document.getElementById('dynamicInputs');
        div.innerHTML = '';
        let fields = [];
        if(type === 'L') fields = [{l:'Leg A', v:60}, {l:'Leg B', v:60}];
        else if(type === 'C') fields = [{l:'Flange A', v:40}, {l:'Web B', v:80}, {l:'Flange C', v:40}];
        else if(type === 'Omega') fields = [{l:'Flange A', v:30}, {l:'Web B', v:50}, {l:'Top C', v:60}, {l:'Web D', v:50}, {l:'Flange E', v:30}];
        
        fields.forEach(f => {
            div.innerHTML += `<div class="row"><div class="col"><label>${f.l}</label><input type="number" class="dim-field" value="${f.v}" oninput="update()"></div></div>`;
        });
    }

    function update() {
        STATE.T = parseFloat(document.getElementById('inp_T').value) || 0;
        STATE.R = parseFloat(document.getElementById('inp_R').value) || 0;
        const K = parseFloat(document.getElementById('inp_K').value) || 0;
        let ang = parseFloat(document.getElementById('inp_A').value);
        if(ang<70) ang=70; if(ang>180) ang=180;
        STATE.Angle = ang;
        STATE.shape = document.getElementById('inp_Shape').value;

        // Math
        const rad = (180 - STATE.Angle) * (Math.PI/180);
        STATE.BA = rad * (STATE.R + (K * STATE.T));
        STATE.OSSB = (STATE.R + STATE.T) * Math.tan(rad/2);

        let dims = [];
        document.querySelectorAll('.dim-field').forEach(el => dims.push(parseFloat(el.value)||0));
        STATE.inputs = dims;

        if (STATE.shape === 'L') {
            STATE.straights = [dims[0]-STATE.OSSB, dims[1]-STATE.OSSB];
            STATE.bendDirs = [-1]; STATE.bendSeq = [0];
        } else if (STATE.shape === 'C') {
            STATE.straights = [dims[0]-STATE.OSSB, dims[1]-2*STATE.OSSB, dims[2]-STATE.OSSB];
            STATE.bendDirs = [-1, -1]; STATE.bendSeq = [0, 1];
        } else if (STATE.shape === 'Omega') {
            STATE.straights = [dims[0]-STATE.OSSB, dims[1]-2*STATE.OSSB, dims[2]-2*STATE.OSSB, dims[3]-2*STATE.OSSB, dims[4]-STATE.OSSB];
            STATE.bendDirs = [-1, 1, 1, -1]; STATE.bendSeq = [0, 3, 1, 2];
        }

        updateTable(dims);
        draw();
    }

    function updateTable(ext) {
        const tb = document.querySelector('#out_Table tbody');
        tb.innerHTML = '';
        let tot = 0;
        STATE.straights.forEach((s, i) => {
            let proc = 0;
            let isEnd = (i===0 || i===STATE.straights.length-1);
            let isOmegaWeb = (STATE.shape === 'Omega' && (i === 1 || i === 3));
            if (isOmegaWeb || isEnd) proc = ext[i] - STATE.OSSB + (STATE.BA/2);
            else proc = ext[i] - 2*STATE.OSSB + STATE.BA;
            tot += proc;
            tb.innerHTML += `<tr><td>${i+1}</td><td class="val-ext">${ext[i].toFixed(2)}</td><td class="val-proc">${proc.toFixed(2)}</td></tr>`;
        });
        document.getElementById('out_Total').innerText = tot.toFixed(2);
        document.getElementById('out_BA').innerText = STATE.BA.toFixed(2);
    }

    // --- Rendering ---
    function draw() {
        const c = document.getElementById('simCanvas');
        const ctx = c.getContext('2d');
        const W = c.width; const H = c.height;
        ctx.clearRect(0,0,W,H);

        const slider = parseFloat(document.getElementById('inp_Slider').value);
        const progress = slider / 100;
        
        // Calc Angles
        let angles = new Array(STATE.bendDirs.length).fill(0);
        let steps = STATE.bendSeq.length;
        let stepIdx = Math.floor(progress * steps);
        if(stepIdx >= steps) stepIdx = steps-1;
        let localP = (progress*steps) - stepIdx;
        const targetRad = (180 - STATE.Angle) * (Math.PI/180);

        for(let i=0; i<stepIdx; i++) angles[STATE.bendSeq[i]] = targetRad * STATE.bendDirs[STATE.bendSeq[i]];
        if(progress>0) angles[STATE.bendSeq[stepIdx]] = (targetRad * STATE.bendDirs[STATE.bendSeq[stepIdx]]) * localP;

        const lbls = STATE.shape==='Omega' ? ['A','E','B','D'] : [`${stepIdx+1}`,`${stepIdx+2}`];
        document.getElementById('step_desc').innerText = progress===0?"FLAT":(progress===1?"FINISHED":`BENDING ${lbls[stepIdx]}`);

        // --- Calculate Skeleton Nodes (Neutral Axis) ---
        let nodes = [{x:0, y:0, ang:0}];
        let ca = 0;
        for(let i=0; i<STATE.straights.length; i++){
            let len = STATE.straights[i];
            let nx = nodes[i].x + len * Math.cos(ca);
            let ny = nodes[i].y + len * Math.sin(ca);
            nodes.push({x:nx, y:ny, ang: ca}); // Store incoming angle
            if(i < angles.length) ca += angles[i];
        }
        // Update last node angle? No, straight segments define vector.

        // --- Camera ---
        ctx.save();
        ctx.translate(VIEW.panX, VIEW.panY);
        const S = VIEW.scale * VIEW.zoom;

        // Anchor
        let anchor = 0;
        if(STATE.shape === 'C') anchor = (stepIdx>=1) ? 1 : 0;
        if(STATE.shape === 'Omega') {
             const anchors = [1, 3, 2, 2];
             anchor = anchors[stepIdx] || 0;
             if(progress===0) anchor = 2;
        }
        let p1 = nodes[anchor]; let p2 = nodes[anchor+1];
        let baseAng = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        let mx = (p1.x+p2.x)/2; let my = (p1.y+p2.y)/2;

        ctx.rotate(-baseAng); ctx.translate(-mx*S, -my*S);

        // --- Draw Bed ---
        let bedY = p1.y*S + (STATE.T*S)/2 + 2;
        ctx.fillStyle = "#f0f0f0"; ctx.fillRect(mx*S - 500, bedY, 1000, 20);
        ctx.strokeStyle = "#ddd"; ctx.strokeRect(mx*S - 500, bedY, 1000, 20);

        // --- DRAW PROFILE (CAD STYLE) ---
        // We will construct the Inner and Outer path
        // Inner Radius = R. Outer Radius = R+T.
        // The skeleton nodes are at the NEUTRAL axis? 
        // For visualization simplicity, let's assume the nodes are on the Inner surface corner (sharp)
        // and we fillet them.
        // Actually, to keep dims accurate to OSSB logic, Nodes are Virtual Sharps of the NEUTRAL axis or Inner?
        // OSSB is calculated on R+T. 
        // Let's draw the profile by tracing lines and arcs.
        
        ctx.lineJoin = "round"; ctx.lineCap = "round";
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--metal-fill');
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--metal-stroke');
        ctx.lineWidth = 1.5;

        drawSolidProfile(ctx, nodes, angles, S);

        // --- DRAW DIMS ---
        drawDimensions(ctx, nodes, angles, S);

        // --- Suction ---
        drawSuction(ctx, nodes[anchor], nodes[anchor+1], S);

        ctx.restore();
    }

    function drawSolidProfile(ctx, nodes, angles, S) {
        // This is a simplified "Thick Line" with specific radii using Stroke only
        // To do filled polygon with distinct inner/outer radii is complex for this snippet.
        // We will simulate it by drawing the Neutral Axis thick, but we want to see the radius.
        
        // Approach: Draw Path of Centerline.
        // Use ctx.lineWidth = T. 
        // But corners need to be arcs.
        // We will manually draw the "Outer" path and "Inner" path and fill between.
        
        ctx.beginPath();
        
        // Helper to get offset points
        const getOffset = (idx, offset) => {
            // Segment vector
            let n1 = nodes[idx], n2 = nodes[idx+1];
            let dx = n2.x - n1.x, dy = n2.y - n1.y;
            let len = Math.sqrt(dx*dx+dy*dy);
            let ux = dx/len, uy = dy/len;
            let nx = -uy, ny = ux; // Normal
            return {x: n1.x*S + nx*offset, y: n1.y*S + ny*offset, ux, uy, nx, ny};
        };

        // We'll just draw the stroke with round joins for now to ensure robustness 
        // while fixing the Dimension lines which was the main request.
        // To "Display Radii" accurately:
        // We will rely on lineJoin="round" which creates a radius of T/2. 
        // This is visually close for T=2, R=2.
        // If R is large, this looks wrong.
        
        // Better Visualization for Large R:
        // Draw the path using arcTo at the corners.
        // Corner Radius = R + T/2 (for neutral axis).
        
        let path = new Path2D();
        let r_neutral = STATE.R + (STATE.T/2);
        
        path.moveTo(nodes[0].x*S, nodes[0].y*S);
        for(let i=1; i<nodes.length-1; i++) {
            // Draw line to "Tangent Start"
            // For sim, simply connecting nodes with arcTo works well
            path.arcTo(nodes[i].x*S, nodes[i].y*S, nodes[i+1].x*S, nodes[i+1].y*S, r_neutral * S);
        }
        path.lineTo(nodes[nodes.length-1].x*S, nodes[nodes.length-1].y*S);
        
        ctx.lineCap = "butt"; // Flat ends
        ctx.strokeStyle = "#263238";
        ctx.lineWidth = STATE.T * S;
        ctx.stroke(path);
        
        // Fill effect (Thin lighter line inside)
        ctx.lineWidth = (STATE.T * S) - 2;
        ctx.strokeStyle = "#cfd8dc";
        ctx.stroke(path);
        
        // Centerline
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 3]);
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.stroke(path);
        ctx.setLineDash([]);
    }

    function drawDimensions(ctx, nodes, angles, S) {
        STATE.straights.forEach((st, i)=>{
            let n1 = nodes[i], n2 = nodes[i+1];
            
            // Calc Values
            let isEnd = (i==0 || i==STATE.straights.length-1);
            let isOmegaWeb = (STATE.shape === 'Omega' && (i === 1 || i === 3));
            let valProc = (isOmegaWeb || isEnd) ? STATE.inputs[i] - STATE.OSSB + (STATE.BA/2) : STATE.inputs[i] - 2*STATE.OSSB + STATE.BA;
            
            // External: This is the user input
            let valExt = STATE.inputs[i];

            // 1. Process Dim (Center to Center) - RED
            let offProc = (STATE.T*S)/2 + (20 * VIEW.zoom);
            drawDimLine(ctx, n1, n2, offProc, valProc.toFixed(2), '#d50000', S, 0);

            // 2. External Dim (Outer Face to Outer Face) - BLUE
            // We need to offset the anchor points by T/2 + OSSB
            // The "Line" should be exactly on the outer surface? 
            // "Exactly on the lines" -> Offset = T/2.
            let offExt = (STATE.T*S)/2 + (2 * VIEW.zoom); // Very close to surface
            // Extension amount = OSSB
            drawDimLine(ctx, n1, n2, offExt, valExt.toFixed(2), '#0055ff', S, STATE.OSSB*S);
        });
    }

    function drawDimLine(ctx, p1, p2, off, txt, col, S, extLen) {
        let ux = p2.x-p1.x, uy = p2.y-p1.y;
        let len = Math.sqrt(ux*ux + uy*uy);
        ux/=len; uy/=len;
        let nx = -uy, ny = ux;

        // Base points (Neutral Axis)
        let b1x = p1.x*S, b1y = p1.y*S;
        let b2x = p2.x*S, b2y = p2.y*S;

        // Dimension Line Points
        let d1x = b1x + nx*off, d1y = b1y + ny*off;
        let d2x = b2x + nx*off, d2y = b2y + ny*off;

        // Adjust for External Extension (Virtual Sharp)
        // Move d1 back by extLen, d2 forward by extLen
        let f1x = d1x - ux*extLen, f1y = d1y - uy*extLen;
        let f2x = d2x + ux*extLen, f2y = d2y + uy*extLen;

        ctx.save();
        ctx.strokeStyle = col; ctx.fillStyle = col;
        ctx.lineWidth = 1.5; ctx.font = `bold ${11*VIEW.zoom}px sans-serif`;

        // Draw Line
        ctx.beginPath(); ctx.moveTo(f1x, f1y); ctx.lineTo(f2x, f2y); ctx.stroke();
        
        // Witness marks (Ticks)
        let tick = 4*VIEW.zoom;
        ctx.beginPath();
        ctx.moveTo(f1x + nx*tick, f1y + ny*tick); ctx.lineTo(f1x - nx*tick, f1y - ny*tick);
        ctx.moveTo(f2x + nx*tick, f2y + ny*tick); ctx.lineTo(f2x - nx*tick, f2y - ny*tick);
        ctx.stroke();

        // Text
        let mx = (f1x+f2x)/2, my = (f1y+f2y)/2;
        let ang = Math.atan2(uy, ux);
        if(ang > Math.PI/2 || ang < -Math.PI/2) ang += Math.PI;

        ctx.translate(mx,my); ctx.rotate(ang);
        // Draw Text Background to clear line
        let tw = ctx.measureText(txt).width+4;
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillRect(-tw/2, -6*VIEW.zoom, tw, 12*VIEW.zoom);
        ctx.fillStyle = col;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(txt, 0, 0);

        ctx.restore();
    }

    function drawSuction(ctx, p1, p2, S) {
        let cx = (p1.x+p2.x)/2 * S; let cy = (p1.y+p2.y)/2 * S;
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        
        ctx.save();
        ctx.translate(cx,cy); ctx.rotate(ang);
        
        let dist = (STATE.T*S)/2 + 2;
        let w = 20*VIEW.zoom, h = 6*VIEW.zoom;
        
        ctx.fillStyle = "rgba(50,50,50,0.2)"; ctx.strokeStyle = "#333";
        ctx.beginPath(); ctx.rect(-w, -dist-h, w*2, h); ctx.fill(); ctx.stroke();
        
        // Stem
        ctx.beginPath(); ctx.moveTo(0, -dist-h); ctx.lineTo(0, -dist-h-15*VIEW.zoom); ctx.stroke();
        
        ctx.restore();
    }
</script>
</body>
</html>
