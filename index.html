<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Frednzon CAD Sim - Precision</title>
    <style>
        :root {
            --bg: #f4f7f6;
            --panel: #ffffff;
            --accent-blue: #0044cc;
            --accent-red: #d32f2f;
            --text: #37474f;
            --border: #cfd8dc;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
            color: var(--text);
        }

        /* Layout */
        .app-layout { display: flex; flex-direction: column; height: 100%; }
        @media (min-width: 900px) {
            .app-layout { flex-direction: row-reverse; }
            .canvas-wrap { flex: 2; height: 100%; border-left: 1px solid var(--border); }
            .controls-wrap { flex: 1; max-width: 420px; box-shadow: -2px 0 10px rgba(0,0,0,0.05); }
        }

        /* Canvas */
        .canvas-wrap {
            position: relative;
            height: 55vh;
            background: #fff;
            /* Precise Engineering Grid */
            background-image: 
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            touch-action: none;
            border-bottom: 1px solid var(--border);
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

        .tools {
            position: absolute; bottom: 15px; right: 15px;
            display: flex; gap: 8px;
        }
        .btn-icon {
            width: 40px; height: 40px;
            background: #fff; border: 1px solid #b0bec5; border-radius: 6px;
            font-size: 18px; color: #546e7a;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); cursor: pointer; user-select: none;
        }
        .btn-icon:active { background: #eceff1; }

        .legend {
            position: absolute; top: 15px; left: 15px;
            background: rgba(255,255,255,0.95);
            padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px;
            font-family: 'Consolas', monospace; font-size: 11px;
            pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        /* Controls */
        .controls-wrap {
            flex: 1; padding: 15px; overflow-y: auto; background: #f8f9fa;
        }
        .panel {
            background: var(--panel); border: 1px solid #e0e0e0;
            border-radius: 6px; padding: 12px; margin-bottom: 10px;
        }
        h3 { margin: 0 0 10px 0; font-size: 12px; color: #78909c; text-transform: uppercase; border-bottom: 2px solid #eceff1; padding-bottom: 5px; }

        .row { display: flex; gap: 10px; margin-bottom: 8px; }
        .col { flex: 1; }
        
        label { display: block; font-size: 11px; font-weight: 700; color: #546e7a; margin-bottom: 3px; }
        input[type="number"], select {
            width: 100%; padding: 8px; border: 1px solid #cfd8dc;
            border-radius: 4px; font-size: 14px; background: #fafafa;
        }
        input:focus { border-color: var(--accent-blue); outline: none; background: #fff; }

        input[type="range"] { width: 100%; margin: 10px 0; accent-color: var(--accent-blue); }
        .info-bar { display: flex; justify-content: space-between; font-size: 11px; font-weight: bold; color: #333; margin-bottom: 5px; }

        /* Table */
        table { width: 100%; border-collapse: collapse; font-size: 11px; }
        th { text-align: left; padding: 6px; background: #eceff1; border-bottom: 1px solid #cfd8dc; color: #607d8b; }
        td { padding: 6px; border-bottom: 1px solid #eee; }
        .txt-blue { color: var(--accent-blue); font-weight: 700; }
        .txt-red { color: var(--accent-red); font-weight: 700; }

    </style>
</head>
<body>

<div class="app-layout">
    <div class="canvas-wrap">
        <canvas id="simCanvas"></canvas>
        
        <div class="legend">
            <span style="color:var(--accent-blue)">├───┤</span> Ext (Virtual Sharp)<br>
            <span style="color:var(--accent-red)">├───┤</span> Proc (Neutral Axis)<br>
            <span style="color:#222">═════</span> Material
        </div>

        <div class="tools">
            <div class="btn-icon" onclick="resetView()">⟲</div>
            <div class="btn-icon" onclick="adjustZoom(0.9)">−</div>
            <div class="btn-icon" onclick="adjustZoom(1.1)">+</div>
        </div>
    </div>

    <div class="controls-wrap">
        <div class="panel">
            <h3>Parameters</h3>
            <div class="row">
                <div class="col"><label>Thickness (mm)</label><input type="number" id="inp_T" value="2.0" step="0.1"></div>
                <div class="col"><label>Inner Radius</label><input type="number" id="inp_R" value="3.0" step="0.1"></div>
            </div>
            <div class="row">
                <div class="col"><label>Angle (°)</label><input type="number" id="inp_A" value="90" min="70" max="180"></div>
                <div class="col"><label>K-Factor</label><input type="number" id="inp_K" value="0.33" step="0.01"></div>
            </div>
        </div>

        <div class="panel">
            <h3>Profile</h3>
            <select id="inp_Shape" style="width:100%; margin-bottom:10px;">
                <option value="L">L-Shape</option>
                <option value="C">C-Channel</option>
                <option value="Omega">Omega (Hat)</option>
            </select>
            <div id="dynamicInputs"></div>
        </div>

        <div class="panel">
            <div class="info-bar">
                <span>CUT LEN: <span id="out_Total">0.00</span></span>
                <span>BA: <span id="out_BA">0.00</span></span>
            </div>
            <input type="range" id="inp_Slider" min="0" max="100" value="0">
            <div style="text-align:center; font-size:10px; font-weight:bold; color:#90a4ae;" id="step_desc">FLAT PATTERN</div>
        </div>

        <div class="panel" style="padding:0;">
            <table id="out_Table">
                <thead><tr><th>SEG</th><th>EXTERNAL</th><th>PROCESS</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        <div style="height:40px;"></div>
    </div>
</div>

<script>
    // --- State ---
    const VIEW = { scale: 2.0, zoom: 1.0, panX: 0, panY: 0, dragging: false, lx: 0, ly: 0 };
    const STATE = { shape: 'L', inputs: [], straights: [], bendDirs: [], bendSeq: [], BA: 0, OSSB: 0, T: 2, R: 3, Angle: 90 };

    // --- Init ---
    window.onload = () => {
        buildUI(); resizeCanvas(); bindEvents(); update();
        document.getElementById('simCanvas').addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    };

    window.addEventListener('resize', () => { resizeCanvas(); draw(); });

    function resizeCanvas() {
        const c = document.getElementById('simCanvas');
        c.width = c.clientWidth; c.height = c.clientHeight;
        if(VIEW.panX===0) { VIEW.panX = c.width/2; VIEW.panY = c.height/2; }
    }

    function bindEvents() {
        document.getElementById('inp_Shape').addEventListener('change', () => { buildUI(); update(); });
        ['inp_T', 'inp_R', 'inp_K', 'inp_A'].forEach(id => document.getElementById(id).addEventListener('input', update));
        document.getElementById('inp_Slider').addEventListener('input', draw);
        
        const c = document.getElementById('simCanvas');
        const start = (x,y) => { VIEW.dragging=true; VIEW.lx=x; VIEW.ly=y; };
        const move = (x,y) => { if(!VIEW.dragging)return; VIEW.panX+=x-VIEW.lx; VIEW.panY+=y-VIEW.ly; VIEW.lx=x; VIEW.ly=y; draw(); };
        const end = () => { VIEW.dragging=false; };

        c.addEventListener('mousedown', e=>start(e.clientX, e.clientY));
        window.addEventListener('mousemove', e=>move(e.clientX, e.clientY));
        window.addEventListener('mouseup', end);
        c.addEventListener('touchstart', e=>start(e.touches[0].clientX, e.touches[0].clientY));
        c.addEventListener('touchmove', e=>move(e.touches[0].clientX, e.touches[0].clientY));
        c.addEventListener('touchend', end);
    }

    function adjustZoom(f) { VIEW.zoom = Math.max(0.1, Math.min(10, VIEW.zoom*f)); draw(); }
    function resetView() { const c = document.getElementById('simCanvas'); VIEW.zoom=1.0; VIEW.panX=c.width/2; VIEW.panY=c.height/2; draw(); }

    // --- Logic ---
    function buildUI() {
        const type = document.getElementById('inp_Shape').value;
        const div = document.getElementById('dynamicInputs');
        div.innerHTML = '';
        const presets = {
            'L': [{l:'Leg A', v:60}, {l:'Leg B', v:60}],
            'C': [{l:'Flange A', v:40}, {l:'Web B', v:80}, {l:'Flange C', v:40}],
            'Omega': [{l:'Flange A', v:30}, {l:'Web B', v:50}, {l:'Top C', v:60}, {l:'Web D', v:50}, {l:'Flange E', v:30}]
        };
        presets[type].forEach(f => {
            div.innerHTML += `<div class="row"><div class="col"><label>${f.l}</label><input type="number" class="dim-field" value="${f.v}" oninput="update()"></div></div>`;
        });
    }

    function update() {
        STATE.T = parseFloat(document.getElementById('inp_T').value) || 0;
        STATE.R = parseFloat(document.getElementById('inp_R').value) || 0;
        const K = parseFloat(document.getElementById('inp_K').value) || 0;
        let ang = parseFloat(document.getElementById('inp_A').value);
        if(ang<70) ang=70; if(ang>180) ang=180;
        STATE.Angle = ang;
        STATE.shape = document.getElementById('inp_Shape').value;

        // Calc
        const rad = (180 - STATE.Angle) * (Math.PI/180);
        STATE.BA = rad * (STATE.R + (K * STATE.T));
        STATE.OSSB = (STATE.R + STATE.T) * Math.tan(rad/2);

        let dims = [];
        document.querySelectorAll('.dim-field').forEach(el => dims.push(parseFloat(el.value)||0));
        STATE.inputs = dims;

        if(STATE.shape==='L') {
            STATE.straights=[dims[0]-STATE.OSSB, dims[1]-STATE.OSSB];
            STATE.bendDirs=[-1]; STATE.bendSeq=[0];
        } else if(STATE.shape==='C') {
            STATE.straights=[dims[0]-STATE.OSSB, dims[1]-2*STATE.OSSB, dims[2]-STATE.OSSB];
            STATE.bendDirs=[-1,-1]; STATE.bendSeq=[0,1];
        } else if(STATE.shape==='Omega') {
            STATE.straights=[dims[0]-STATE.OSSB, dims[1]-2*STATE.OSSB, dims[2]-2*STATE.OSSB, dims[3]-2*STATE.OSSB, dims[4]-STATE.OSSB];
            STATE.bendDirs=[-1,1,1,-1]; STATE.bendSeq=[0,3,1,2];
        }

        updateTable(dims);
        draw();
    }

    function updateTable(ext) {
        const tb = document.querySelector('#out_Table tbody');
        tb.innerHTML = '';
        let tot = 0;
        STATE.straights.forEach((s, i) => {
            let isEnd = (i===0 || i===STATE.straights.length-1);
            let isOmegaWeb = (STATE.shape === 'Omega' && (i === 1 || i === 3));
            let proc = (isOmegaWeb || isEnd) ? ext[i] - STATE.OSSB + (STATE.BA/2) : ext[i] - 2*STATE.OSSB + STATE.BA;
            tot += proc;
            tb.innerHTML += `<tr><td>${i+1}</td><td class="txt-blue">${ext[i].toFixed(2)}</td><td class="txt-red">${proc.toFixed(2)}</td></tr>`;
        });
        document.getElementById('out_Total').innerText = tot.toFixed(2);
        document.getElementById('out_BA').innerText = STATE.BA.toFixed(2);
    }

    // --- Rendering ---
    function draw() {
        const c = document.getElementById('simCanvas');
        const ctx = c.getContext('2d');
        const W = c.width; const H = c.height;
        ctx.clearRect(0,0,W,H);

        const progress = parseFloat(document.getElementById('inp_Slider').value) / 100;
        
        let angles = new Array(STATE.bendDirs.length).fill(0);
        let steps = STATE.bendSeq.length;
        let stepIdx = Math.floor(progress * steps);
        if(stepIdx >= steps) stepIdx = steps-1;
        let localP = (progress * steps) - stepIdx;
        const targetRad = (180 - STATE.Angle) * (Math.PI/180);

        for(let i=0; i<stepIdx; i++) angles[STATE.bendSeq[i]] = targetRad * STATE.bendDirs[STATE.bendSeq[i]];
        if(progress > 0) angles[STATE.bendSeq[stepIdx]] = (targetRad * STATE.bendDirs[STATE.bendSeq[stepIdx]]) * localP;

        const lbls = STATE.shape==='Omega' ? ['A','E','B','D'] : [`${stepIdx+1}`,`${stepIdx+2}`];
        document.getElementById('step_desc').innerText = progress===0?"FLAT PATTERN":(progress===1?"FINISHED":`BENDING ${lbls[stepIdx]}`);

        // Nodes (Neutral Axis)
        let nodes = [{x:0, y:0}];
        let ca = 0;
        for(let i=0; i<STATE.straights.length; i++){
            let len = STATE.straights[i];
            let nx = nodes[i].x + len * Math.cos(ca);
            let ny = nodes[i].y + len * Math.sin(ca);
            nodes.push({x:nx, y:ny});
            if(i < angles.length) ca += angles[i];
        }

        // Camera
        ctx.save();
        ctx.translate(VIEW.panX, VIEW.panY);
        const S = VIEW.scale * VIEW.zoom;

        // Anchor
        let anchor = 0;
        if(STATE.shape === 'C') anchor = (stepIdx>=1) ? 1 : 0;
        if(STATE.shape === 'Omega') {
            const anchors = [1, 3, 2, 2];
            anchor = anchors[stepIdx] || 0;
            if(progress===0) anchor = 2;
        }
        let p1 = nodes[anchor]; let p2 = nodes[anchor+1];
        let baseAng = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        let mx = (p1.x+p2.x)/2; let my = (p1.y+p2.y)/2;

        ctx.rotate(-baseAng); ctx.translate(-mx*S, -my*S);

        // Bed
        let bedY = p1.y*S + (STATE.T*S)/2 + 2;
        ctx.fillStyle = "#f1f1f1"; ctx.fillRect(mx*S - 500, bedY, 1000, 20);
        ctx.strokeStyle = "#ddd"; ctx.strokeRect(mx*S - 500, bedY, 1000, 20);
        ctx.fillStyle = "#ccc"; ctx.beginPath(); ctx.moveTo(mx*S-25, bedY+30); ctx.lineTo(mx*S, bedY+2); ctx.lineTo(mx*S+25, bedY+30); ctx.fill();

        // PART
        drawPartProfile(ctx, nodes, S);

        // DIMS
        drawDimensions(ctx, nodes, S);

        // SUCTION
        drawSuction(ctx, nodes[anchor], nodes[anchor+1], S);

        ctx.restore();
    }

    function drawPartProfile(ctx, nodes, S) {
        ctx.lineJoin = "round"; ctx.lineCap = "round";
        
        // Solid Outer
        ctx.lineWidth = STATE.T * S;
        ctx.strokeStyle = "#37474f";
        ctx.beginPath();
        nodes.forEach((n,i)=>{ i==0 ? ctx.moveTo(n.x*S, n.y*S) : ctx.lineTo(n.x*S, n.y*S); });
        ctx.stroke();

        // Inner Fill
        ctx.lineWidth = (STATE.T * S) - 2;
        ctx.strokeStyle = "#cfd8dc";
        ctx.stroke();
    }

    function drawDimensions(ctx, nodes, S) {
        const halfT = (STATE.T * S) / 2;

        STATE.straights.forEach((st, i) => {
            let n1 = nodes[i], n2 = nodes[i+1];
            
            let dx = n2.x - n1.x, dy = n2.y - n1.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            let ux = dx/len, uy = dy/len;
            let nx = -uy, ny = ux; // Outward Normal

            // 1. Process Dim (Red)
            let isEnd = (i==0 || i==STATE.straights.length-1);
            let isOmegaWeb = (STATE.shape === 'Omega' && (i === 1 || i === 3));
            let valProc = (isOmegaWeb || isEnd) ? STATE.inputs[i] - STATE.OSSB + (STATE.BA/2) : STATE.inputs[i] - 2*STATE.OSSB + STATE.BA;
            let offProc = halfT + (25 * VIEW.zoom);
            drawDimLine(ctx, n1, n2, nx, ny, ux, uy, 0, offProc, 0, valProc.toFixed(2), "#cc0000", S);

            // 2. External Dim (Blue) - ATTACHED TO EDGE
            let valExt = STATE.inputs[i];
            
            // Offset: Exactly at the Surface
            let offExt = halfT; 
            
            // Move Dim Line Outwards so it doesn't overlap line
            let dimLineHeight = halfT + (60 * VIEW.zoom);

            // Extension Length (OSSB scaled)
            let extLen = STATE.OSSB * S;

            drawDimLine(ctx, n1, n2, nx, ny, ux, uy, offExt, dimLineHeight, extLen, valExt.toFixed(2), "#0044cc", S, true);
        });
    }

    function drawDimLine(ctx, n1, n2, nx, ny, ux, uy, surfOffset, dimOffset, extLen, txt, col, S, isExt=false) {
        // Base Points (Neutral Axis scaled)
        let bx1 = n1.x*S, by1 = n1.y*S;
        let bx2 = n2.x*S, by2 = n2.y*S;

        // "Virtual Sharp" Points on the Surface
        // Start at Surface -> extend backward/forward by OSSB
        // Surface Point = Base + Normal * surfOffset
        let sx1 = bx1 + nx*surfOffset, sy1 = by1 + ny*surfOffset;
        let sx2 = bx2 + nx*surfOffset, sy2 = by2 + ny*surfOffset;

        // Virtual Sharps (Origin of Witness Lines)
        let vs1x = sx1 - ux*extLen, vs1y = sy1 - uy*extLen;
        let vs2x = sx2 + ux*extLen, vs2y = sy2 + uy*extLen;

        // Dimension Line Points
        let d1x = bx1 + nx*dimOffset - ux*extLen;
        let d1y = by1 + ny*dimOffset - uy*extLen;
        let d2x = bx2 + nx*dimOffset + ux*extLen;
        let d2y = by2 + ny*dimOffset + uy*extLen;

        ctx.save();
        ctx.strokeStyle = col; ctx.fillStyle = col;
        ctx.lineWidth = 1; ctx.font = `bold ${12*VIEW.zoom}px 'Arial', sans-serif`;

        // Draw Main Line
        ctx.beginPath(); ctx.moveTo(d1x, d1y); ctx.lineTo(d2x, d2y); ctx.stroke();

        // Draw Extension Lines
        if(isExt) {
            // Draw EXACTLY from Virtual Sharp to Dim Line
            // No gap, touches corner
            ctx.beginPath();
            ctx.moveTo(vs1x, vs1y); ctx.lineTo(d1x, d1y);
            ctx.moveTo(vs2x, vs2y); ctx.lineTo(d2x, d2y);
            ctx.stroke();
        } else {
            let tick = 4 * VIEW.zoom;
            ctx.beginPath();
            ctx.moveTo(d1x + nx*tick, d1y + ny*tick); ctx.lineTo(d1x - nx*tick, d1y - ny*tick);
            ctx.moveTo(d2x + nx*tick, d2y + ny*tick); ctx.lineTo(d2x - nx*tick, d2y - ny*tick);
            ctx.stroke();
        }

        // Arrows
        drawArrow(ctx, d1x, d1y, d2x, d2y, VIEW.zoom);
        drawArrow(ctx, d2x, d2y, d1x, d1y, VIEW.zoom);

        // Text
        let mx = (d1x+d2x)/2, my = (d1y+d2y)/2;
        let ang = Math.atan2(ny, nx) - Math.PI/2; 
        if(ang > Math.PI/2 || ang < -Math.PI/2) ang += Math.PI;

        ctx.translate(mx,my); ctx.rotate(ang);
        
        let tw = ctx.measureText(txt).width + 6;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(-tw/2, -6*VIEW.zoom, tw, 12*VIEW.zoom);
        
        ctx.fillStyle = col;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(txt, 0, 0);

        ctx.restore();
    }

    function drawArrow(ctx, x1, y1, x2, y2, z) {
        let len = 12 * z; // Longer
        let width = 2.5 * z; // Slimmer
        let ang = Math.atan2(y2-y1, x2-x1);
        
        ctx.save();
        ctx.translate(x1, y1); ctx.rotate(ang);
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(len, width);
        ctx.lineTo(len, -width);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function drawSuction(ctx, p1, p2, S) {
        let cx = (p1.x+p2.x)/2 * S; let cy = (p1.y+p2.y)/2 * S;
        let ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
        
        ctx.save();
        ctx.translate(cx,cy); ctx.rotate(ang);
        
        let dist = (STATE.T * S)/2 + 2;
        let w = 18*VIEW.zoom, h = 5*VIEW.zoom;
        
        ctx.strokeStyle = "#333"; ctx.lineWidth=1.5; ctx.fillStyle="rgba(0,0,0,0.05)";
        ctx.beginPath(); ctx.rect(-25*VIEW.zoom, -dist-h, w, h); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.rect(7*VIEW.zoom, -dist-h, w, h); ctx.fill(); ctx.stroke();
        ctx.beginPath(); 
        ctx.moveTo(-16*VIEW.zoom, -dist-h); ctx.lineTo(-16*VIEW.zoom, -dist-h-12*VIEW.zoom);
        ctx.moveTo(16*VIEW.zoom, -dist-h); ctx.lineTo(16*VIEW.zoom, -dist-h-12*VIEW.zoom);
        ctx.moveTo(-16*VIEW.zoom, -dist-h-12*VIEW.zoom); ctx.lineTo(16*VIEW.zoom, -dist-h-12*VIEW.zoom);
        ctx.moveTo(0, -dist-h-12*VIEW.zoom); ctx.lineTo(0, -dist-h-30*VIEW.zoom);
        ctx.stroke();

        ctx.restore();
    }
</script>
</body>
</html>
